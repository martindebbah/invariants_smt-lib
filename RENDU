           Mini-projet 2 : Synthèse d'invariant en SMT-LIB
                            fichier RENDU
                     (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 19 décembre 2022

Identité
--------
Nombre de binôme: 60
Nom, prénom 1: Cherifi Rayan
Nom, prénom 2: Debbah Martin


Questions sur votre code
------------------------

** Exercice 2 **

0. Avez-vous testé que `make invariants` s'exécute sans erreurs ou
   warnings, puis que `./invariants` produit une sortie au format
   SMT-LIB, et enfin que cette sortie est acceptée par Z3 ?

La commande `make` s'exécute sans erreur, et la sortie produite par 
`./invariants` est bien au format SMT-LIB et est acceptée par Z3.

---

1. Le type `term` est un type récursif : quel type de fonction est-il
   naturel d'utiliser ? Quels sont vos cas de base et quelle quantité
   strictement décroissante au cours des appels successifs vous assure
   la terminaison ?
   
Il est naturel d'utiliser des fonctions récursives. Nos cas de base sont
`Const` et `Var`. Nous sommes assurés de la terminaison vu que ces fonctions
nécessitent un nombre d'opérations fini lié au `term`. Et dans tout les cas autres 
que ceux de base, ces opérations sont effectuées sur une quantité strictement
décroissante de `term` pour un `term` constitué de`Add` ou de `Mult`.

---

2. Pour l'implémentation de `str_condition`, quelles sont les
   fonctions auxiliaires que vous avez utilisées et/ou écrites ? (Par
   une fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length` ou
   `List.rev_append`, ou une fonction `aux_str_condition` que vous
   avez écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `str_condition`.
   
Nous avons utilisé la fonction auxiliaire `List.fold_left`. Cela nous permet
de concaténer chaque élément de la liste passée en paramètre sous sa forme
de chaîne de caractères. Avec comme chaîne de base "(Invar", puis chaque
élément de la liste y sera concaténé à droite, puis on ajoute ")" au résultat
obtenu. (= "(Invar x1 x2)")

---

3. Pour l'implémentation de `str_assert_forall`, quelles sont les
   fonctions auxiliaires que vous avez utilisées et/ou écrites ?
   Expliquez en quelques phrases en français comment ces fonctions
   auxiliaires sont utilisées dans votre implémentation de la fonction
   `str_assert_forall`.
   
Nous avons utilisé la fonction `str_assert` qui nous permet d'écrire "assert"
avant notre assertion. Nous avons aussi utilisé une fonction récursive interne,
qui nous permet d'ajouter le bon nombre de variables.
   
---

4. Le langage de programmation WA suppose que les mises à jour des
   variables `x1`, ..., `xk` sont simultanées : par exemple, si `x1`
   vaut `1` et x2 vaut `1`, exécuter

   x1 = x2 + 1;
   x2 = x1 + 1;

   résulte en `x1` valant `2` et `x2` valant `2`. En Java, les mises à
   jour sont séquentielles et le résultat serait que `x1` vaudrait `2`
   et `x2` vaudrait `3`. Expliquez en français comment modifier le
   code pour construire un programme SMT-LIB plus proche de la façon
   dont les variables sont mises à jour en Java.

Il faudrait ajouter des entiers pour stocker une copie de la valeur initiale 
de chaque variable. Par exemple, pour tout x1, x2 on au aurait donc x3, x4 comme 
suit : `x3 = x1`, `x4 = x2`, `x1 = x4 + 1` et `x2 = x3 + 1`

---
5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

Nous avons en plus des fonctions initales dans le projet, rajouté des fonctions 
auiliaires tel que xn int -> string pour simplifier l'affichage du résultat.


